---
layout: post
title: Moving Platforms
date: 2017-11-28T13:30:00.000Z
author: Connor King
categories:
  - Blog
  - Low-Level Programming
  - Development
  - Endless Runner
img: run.png
thumb: c_thumb.jpg
published: true
---

<b>Day 3 </b>Adding more platforms and item pooling.<!--more-->

I started first by creating a new platform a random distance from the last when the end of the platform was on screen and when a platform was off screen, I deleted it. I	 realised that this was causing an un-necessary waste of processing power. Instead, I created a vector of platforms and started with two platforms. I then would spawn more platforms at a random distance from the last until the last platform’s right most x co-ordinate was off screen to the right and push them on to the vector. Now when a platform’s right most x co-ordinate is off screen to the left, a bool named active is turned false, which allows the platform to be re-used and re-activated when spawning new platforms, which saves deleting and creating a new platform. 

#### How does it work?
```C++
void EndlessGame::generatePlatforms()
{
	// set inactive platforms
	for (int i = 0; i < platform_vector.size(); i++)
	{
		if (platform_vector[i].returnMaxX() < -10)
		{
			platform_vector[i].active = false;
		}
	}

	//find the furthest x point of the platforms, set the spawn x & y
	int max_platform_x = 0;
	int spawn_x = 0;
	int spawn_y = 0;
	int gap_size = rand() % 100 + 20;
	for (int i = 0; i < platform_vector.size(); i++)
	{
		if (platform_vector[i].returnMaxX() > max_platform_x)
		{
			max_platform_x = platform_vector[i].returnMaxX();
			spawn_x = platform_vector[i].returnMaxX() + gap_size;
			spawn_y = platform_vector[i].returnYPos() + 26;
		}
	}

	//move inactive platforms if available, if not, make a new one
	if (max_platform_x < game_width)
	{
		for (int i = 0; i < platform_vector.size(); i++)
		{
			if (platform_vector[i].active == false)
			{
				platform_vector[i].pos_x = spawn_x;
				platform_vector[i].pos_y = spawn_y;
				platform_vector[i].active = true;
				break;
			}
			else if (i = platform_vector.size())
			{
				Platform* platform = new Platform(spawn_x, spawn_y);
				platform_vector.push_back(*platform);
			}
		}
	}
}
```
