---
layout: post
title: Sliding Blocks and Pressure Button
date: 2018-02-20T13:30:00.000Z
author: Connor King
categories:
  - Blog
  - Low-Level Programming
  - Development
  - Birdman
img: bird.png
thumb: c_thumb.jpg
published: true
---

<b>Day 4 </b>Adding sliding blocks and pressure button.<!--more-->

I created a new class named sliding blocks which is derived from the interactable class. This is a block, which when collided with, slides in the direction of which it was pushed until it hits a wall or another block. The walls are just more blocks that are not rendered and cannot be collided with by the player, this allowed me to create a border around the sliding area. The pressure button is a just a button that check to see if a block is on top instead of a player and if so, it becomes active.

#### Sliding Blocks Class
```C++
class SlidingBlock :
	public Interactable
{
public:
	SlidingBlock(int x, int y);
	SlidingBlock(int x, int y, int w, int h, bool wall);
	~SlidingBlock();
	
	bool moving			= false;
	bool isWall			= false;
	float getX()		{ return pos_x; }
	float getY()		{ return pos_y; }
	float getWidth()	{ return width; }
	float getHeight()	{ return height; }
	void slide			(double delta_time);
	void blockHit		(float hit_x, float hit_y, bool wall);	
	void slideDirection	(Direction dir);

	Collider* col		= new Collider;

	//inherited 
	bool loadAvatar		(ASGE::Renderer* renderer) override;
	bool render			(ASGE::Renderer* renderer) override;

private:
	float pos_x;
	float pos_y;
	float height = 50;
	float width = 50;

	Direction direction = Direction::NONE;
	ASGE::Sprite* avatar = nullptr;
};
```
####How it Works:
```C++

//When player collides
void SlidingBlock::slideDirection(Direction dir)
{
	if (!moving)
	{
		switch (dir)
		{
		case Direction::UP:
			direction = Direction::UP;
			moving = true;
			break;
		case Direction::DOWN:
			direction = Direction::DOWN;
			moving = true;
			break;
		case Direction::LEFT:
			direction = Direction::LEFT;
			moving = true;
			break;
		case Direction::RIGHT:
			direction = Direction::RIGHT;
			moving = true;
			break;
		case Direction::NONE:
			direction = Direction::NONE;
			break;
		}
	}	
}

//until it collides with a wall or block
void SlidingBlock::slide(double delta_time)
{
	if (!isWall)
	{
		if (moving)
		{
			switch (direction)
			{
			case Direction::UP:
				pos_y -= 200 * (delta_time / 1000);
				break;
			case Direction::DOWN:
				pos_y += 200 * (delta_time / 1000);
				break;
			case Direction::LEFT:
				pos_x -= 200 * (delta_time / 1000);
				break;
			case Direction::RIGHT:
				pos_x += 200 * (delta_time / 1000);
				break;
			}
		}
	}	
}
```
